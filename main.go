package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"io"
	"log"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/exp/maps"
	"golang.org/x/tools/go/packages"
)

func getPkgFiles() (funcInfo, *packages.Package, error) {
	// only one package!
	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes | packages.NeedCompiledGoFiles}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		return nil, nil, err
	}
	if len(pkgs) != 1 {
		return nil, nil, fmt.Errorf("supports single package, not %d", len(pkgs))
	}
	pkg := pkgs[0]
	if len(pkg.Errors) > 0 {
		var err error
		for _, pe := range pkg.Errors {
			err = errors.Join(err, pe)
		}
		return nil, nil, err
	}
	ret := make(funcInfo)
	for _, a := range pkg.Syntax {
		file := stripCwd(pkg.Fset.Position(a.Pos()).Filename)
		ret[file] = functions(pkg.Fset, a)
	}
	return ret, pkg, nil
}

func stripCwd(s string) string {
	cwd, _ := os.Getwd()
	x, _ := strings.CutPrefix(s, cwd+"/")
	return x
}

type funcInfo map[string]map[string][2]int

func (fi funcInfo) Lookup(file string, row int) string {
	for f, r := range fi[file] {
		b, e := r[0], r[1]
		if b <= row && row <= e {
			return f
		}
	}
	return ""
}

func functions(fset *token.FileSet, a *ast.File) map[string][2]int {
	res := make(map[string][2]int)
	pkg := a.Name.String()
	ast.Inspect(a, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.FuncDecl:
			res[pkg+":"+nameOf(n)] = [2]int{fset.Position(n.Pos()).Line, fset.Position(n.End()).Line}
		}
		return true
	})
	return res
}

// nameOf returns the function (foo) or method name (foo.bar) for
// the given function declaration. If the AST is incorrect for the
// receiver, it assumes a function instead.
// NOTE(sr): taken from go/ast
func nameOf(f *ast.FuncDecl) string {
	if r := f.Recv; r != nil && len(r.List) == 1 {
		// looks like a correct receiver declaration
		t := r.List[0].Type
		// dereference pointer receiver types
		if p, _ := t.(*ast.StarExpr); p != nil {
			t = p.X
		}
		// the receiver type must be a type name
		if p, _ := t.(*ast.Ident); p != nil {
			return p.Name + "." + f.Name.Name
		}
		// otherwise assume a function instead
	}
	return f.Name.Name
}

func reports(r io.Reader, funcs funcInfo) (map[string][]string, error) {
	scan := bufio.NewScanner(r)
	ret := make(map[string][]string)
	for scan.Scan() {
		file, row, line := extract(scan.Bytes())
		line = maybeFixup(line, funcs)
		if fun := funcs.Lookup(file, row); fun != "" {
			ret[fun] = append(ret[fun], line)
		}
	}
	return ret, scan.Err()
}

var exp = regexp.MustCompile(`^([a-zA-Z./-]+):([0-9]+):[0-9]+: (.*)$`) // NOTE(sr): no match for <autogenerated>

func extract(bs []byte) (file string, row int, line string) {
	match := exp.FindStringSubmatch(string(bs))
	if len(match) < 4 {
		return
	}
	file = match[1]
	row, _ = strconv.Atoi(match[2])
	line = match[3]
	return
}

var reference = regexp.MustCompile(`at ([a-zA-Z./-]+):([0-9]+):([0-9]+)$`) // NOTE(sr): no match for <autogenerated>:1

// "at pkg/vm/compiler.go:30:2" -> "at vm:strings.String"
func maybeFixup(s string, funcs funcInfo) string {
	match := reference.FindStringSubmatch(s)
	if len(match) == 4 {
		file := match[1]
		row, _ := strconv.Atoi(match[2])
		fun := funcs.Lookup(file, row)
		if fun != "" {
			s = s[:len(s)-len(match[1])-len(match[2])-len(match[3])-2] + fun
		}
	}
	return s
}

func buildOutput(pkg *packages.Package) (io.Reader, error) {
	buf := bytes.Buffer{}
	args := []string{
		"build",
		"-gcflags", "-m=2",
	}
	args = append(args, flag.Args()...)
	if err := forkGo(&buf, args...); err != nil {
		return nil, err
	}
	return &buf, nil
}

func forkGo(w io.Writer, args ...string) error {
	cmd := exec.Command("go", args...)
	cmd.Stderr = w
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("go %s\n: %s %v", strings.Join(args, " "), string(err.(*exec.ExitError).Stderr), err)
	}
	return nil
}

func main() {
	flag.Parse()
	log.SetFlags(log.Lshortfile)

	files, pkg, err := getPkgFiles()
	if err != nil {
		log.Fatal(err)
	}

	out, err := buildOutput(pkg)
	if err != nil {
		log.Fatal(err)
	}

	report, err := reports(out, files)
	if err != nil {
		log.Fatal(err)
	}

	funcs := maps.Keys(report)
	sort.Strings(funcs)
	for _, f := range funcs {
		for _, r := range report[f] {
			fmt.Printf("%s: %s\n", f, r)
		}
	}
}
